#!/bin/bash

#unrarall
# Copyright (C) 2011, 2012 Brendan Le Foll <brendan@fridu.net>
# Copyright (C) 2011, 2012  Dan Liew <dan@su-root.co.uk>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
##########################################################################

# Set some defaults
declare -x DIR="`pwd`"
declare -ix CLEAN=0
declare -rx UNRARALL_VERSION="0.2.9"
declare -ix FORCE_CLEAN=0
declare -ix VERBOSE=0
declare -ix QUIET=0
declare -x UNRAR_METHOD="e"
declare -x UNRARALL_BIN="" #Leave empty to let unrarall to loop through UNRAR_BINARIES, setting this will disable searching through UNRAR_BINARIES
declare -x UNRAR_BINARIES=(unrar 7z) #Array of binaries to try and use, the order here is the order of precedence
declare -x UNRARALL_PID="$$"

function usage()
{
  echo "Usage: unrarall [ --dir DIRECTORY ] [ --clean | --force ] [ --full-path ] [ --verbose | --quiet ] [--7zip]
               unrarall --help
         unrarall --version

  Usage (short options):
           unrarall [ -d DIRECTORY ] [ -c | -f ] [ -v | -q ] [-7]
         unrarall -h
DESCRIPTON
unrarall is a utility to unrar and cleanup (delete) all rar files within a directory DIRECTORY. Sub-directories are automatically recursed and if a rar file exists in a sub-directory then the rar file is extracted into that subdirectory.

Use --clean if you want to cleanup. Otherwise no cleaning is done. It can also be used to delete rar files that have already been used for extraction with --force. Use with caution!

OPTIONS

-7, --7zip       Force using 7zip instead of trying to automatically find a program to extract the rar files.
-c, --clean      Clean after unrar. If the extraction fails then the directory will NOT be cleaned. Use --force to override this.
-d, --dir        Use directory DIRECTORY. If this argument is not supplied the current working directory is used.
-f, --force      Force clean even if unrar fails. Implies --clean. Use this if you've already used unrarall on the directory before
                 and now you want to remove the rar files. This should be pretty fast as unrar is set to not overwrite already extracted files.
--full-path      Extract full path inside rar files instead of just extracting the files in the rar file which is the default behaviour.
-h, --help       Displays this help message and exits.
-v, --verbose    Show extraction progress as unrarall executes. This is not done by default
-q, --quiet      Be completely quiet. No output will be written to the screen
--version        Give version information version.

VERSION: $UNRARALL_VERSION

"
}

function clean-up
{
	#perform any necessary clean up

	message error "unrarall is exiting"
	exit 1;
}

#Catch exit signals
trap clean-up SIGQUIT SIGINT SIGTERM

#function to display pretty messages
function message()
{
  #Assume $1 is message type & $2 is message
  #See http://www.frexx.de/xterm-256-notes/ for information on xterm colour codes

  if [ "$QUIET" -ne 1 ]; then
    case "$1" in
      error)
        #use escape sequence to show red text
        echo -e "\033[31m${2}\033[0m" 1>&2
      ;;
      ok)
        #use escape sequence to show green text
        echo -e "\033[32m${2}\033[0m"
      ;;
      nnl)
        #use echo -n to avoid new line
        echo -n "$2"
        ;;
      info)
        echo "$2"
        ;;
      *)
        echo "$2"
    esac
  fi
}

#function to get flags for unrar binary
function getUnrarFlags()
{
  #$1 is assumed to be unrar binary name
  case "$1" in
    unrar)
      echo -o+ -y
    ;;
    7z)
      echo -y
    ;;
    *)
      #This code should only be reached if the programmer has made an error
      message error "Failed to determine flags for unsupported program \"$1\""
      #We will probably be called in a sub shell but we need to kill the parent shell
      kill -9 ${UNRARALL_PID}
      exit 1;
    ;;
  esac
}

# Parse command line arguments
while [ -n "$1" ]; do
  case "$1" in
    -h | --help )
      usage
      exit 0
      ;;
    --version )
      echo "$UNRARALL_VERSION"
      exit 0
      ;;
    -d | --dir )
      shift
      DIR="$1"
      ;;
    -c | --clean )
      CLEAN=1
      ;;
    -f | --force )
      FORCE_CLEAN=1
      CLEAN=1
      ;;
    -v | --verbose )
      VERBOSE=1
      ;;
    -q | --quiet )
      VERBOSE=0
      QUIET=1
      ;;
    --full-path )
      UNRAR_METHOD="x"
      ;;
    -7 | --7zip)
      UNRARALL_BIN=7z
      ;;
    *)
      # user issued unrecognised option
      message error "Unrecognised option: $1"
      usage
      exit 1
      ;;
  esac
  shift
done

# Current Dir check
if [ "${DIR}" == "." ]; then
  DIR="`pwd`"
fi


#If No user specified binary, cycle through array and try and find a binary that can be used
if [ -z "${UNRARALL_BIN}" ]; then
  for (( index=0; index < ${#UNRAR_BINARIES[@]}; index++)); do
    #Check for binary
    [ $VERBOSE -eq 1 ] && message nnl "Looking for ${UNRAR_BINARIES[$index]}..."
    if type -P ${UNRAR_BINARIES[$index]} 2>&1 > /dev/null ; then
      #Binary found
      UNRARALL_BIN="${UNRAR_BINARIES[$index]}"
      [ $VERBOSE -eq 1 ] && message ok "found"
      break;
    else
    	[ $VERBOSE -eq 1 ] && message error "not found"
    fi

    #check if end of list
    if [ $index -eq $(( ${#UNRAR_BINARIES[@]} -1)) ]; then
	message error "Failed to find binary to perform rar extraction. The following binaries were looked for ${UNRAR_BINARIES[*]}"
	exit 1;
    fi
  done
else
  #check the manually specified binary exists
  if ! type -P ${UNRARALL_BIN} 2>&1 > /dev/null ; then
  	message error "The manually specified binary ${UNRARALL_BIN} cannot be found"
	exit 1;
  fi
fi

#Inform the user about the binary chosen
[ $VERBOSE -eq 1 ] && message info "Using \"${UNRARALL_BIN}\" to extract rar files" ;

# Check $DIR exists and is a directory
if [ -d "$DIR" ]; then
  message normal "Working over directory \"${DIR}\""
else
  message error "Cannot find directory \"${DIR}\""
  exit 1;
fi

# Check if there is an "unrar" running already, if so, exit
if ps -ef | grep -v grep | grep -v unrarall | grep ${UNRARALL_BIN} ; then
  message error "unrarall or ${UNRARALL_BIN} is allready running. Please only run this script once"
  exit 0
fi

CURRENT_DIR=`pwd`

#find all files
COUNT=0

#modify IFS for new lines so filenames with spaces do not get split
IFS_TEMP=$IFS
IFS=$(echo -en "\n\b")

#assuming only the .rar files are of interest
for file in $(find "$DIR" -name '*.rar'); do
  let COUNT=COUNT+1
  message nnl "Extracting (${UNRAR_METHOD}) \"$file\"..."
  filename=`basename "$file"`
  dirname=`dirname "$file"`

  #Strip .rar extension off filename
  sfilename="${filename%.rar}"

  # move to directory
  cd "$dirname"

  # unrar file with unrar e
  if [ "$VERBOSE" -eq 1 ]; then
    ${UNRARALL_BIN} ${UNRAR_METHOD} $( getUnrarFlags ${UNRARALL_BIN}) "$filename"
  else
    ${UNRARALL_BIN} ${UNRAR_METHOD} $( getUnrarFlags ${UNRARALL_BIN}) "$filename" >/dev/null
  fi
  SUCCESS=$?

  # if fail remove from count
  if [ "$SUCCESS" -eq 0 ]; then
    message ok "ok";
  else
    let COUNT=COUNT-1
    message error "failed"
  fi

  # cleanup all rar files in the current directory
  if [ "$CLEAN" -eq 1 ] ; then
    if [ "$SUCCESS" -eq "0" ] || [ "$FORCE_CLEAN" -eq 1 ]; then
      message info "Cleaning $file"
      #-maxdepth 1 is very important, we only want to delete rar files in the current directory!
      find . -maxdepth 1 -type f -iregex '\./'"$sfilename"'.r\([0-9]+\|ar\)$' -exec rm $( [ $VERBOSE -eq 1 ] && echo '-v') '{}' \;

    else
      message error "Couldn't do requested clean because ${UNRARALL_BIN} extracted unsuccessfully. Use --force to override this behaviour"
    fi
  fi
  cd "$CURRENT_DIR"
done
IFS=$IFS_TEMP

if [ "$QUIET" -ne 1 ]; then
  if [ "$COUNT" -ne 0 ]; then
    EXIT_PHRASE="found and extracted"
    if [ "$CLEAN" -eq 1 ]; then
      EXIT_PHRASE="found, extracted and removed"
    fi
    message info "$COUNT rar files $EXIT_PHRASE"
  else
    message error "no rar files extracted"
  fi
fi
